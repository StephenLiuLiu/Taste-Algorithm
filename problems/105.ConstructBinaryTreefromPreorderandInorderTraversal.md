## 题目地址

- [地址](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## 题目描述

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20@
    /  \
   15   7

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路
- 二叉树三种遍历定义就是以递归的形式定义
- 找到左子树的先序遍历, 左子树的中序遍历, 就和缩小了问题的规模
- 中序遍历（左子树->根结点->右子树）
- 先序遍历（根结点->左子树->右子树）

## 关键点解析

- 深度优先搜索

## 代码

- 语言支持：Python，Java，JS

Python Code:

```python

```

Java Code:

```java

```

Javascript Code:
**知识点：slice、中序遍历、先序遍历**
```js
var buildTree = function(preOrder, inOrder) {
    if(inOrder.length == 0 && preOrder.length == 0) {
        return null;
    };
    let root = {};
    root.val = preOrder[0];
    let rootIdxInOrder = inOrder.indexOf(root.val); 
    let leftTreeInOrder = inOrder.slice(0, rootIdxInOrder); //左子树的中序遍历
    let leftTreePreOrder = preOrder.slice(1, leftTreeInOrder.length + 1); //左子树的先序遍历 
    root.left = buildTree(leftTreePreOrder, leftTreeInOrder); //递归的寻找赋值
    let rightTreeInOrder = inOrder.slice(rootIdxInOrder + 1); //右子树的中序遍历
    let rightTreePreOrder = preOrder.slice(rootIdxInOrder + 1); //右子树的先序遍历
    root.right  = buildTree(rightTreePreOrder, rightTreeInOrder);
    return root;
};
```

## 扩展

